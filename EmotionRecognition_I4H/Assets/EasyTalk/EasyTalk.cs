/*
 * This source code is (c)Copyright 2017 Realtime VR, LLC. All rights reserved.
 * 
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 * */

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Security.Cryptography;

[RequireComponent(typeof(Transform[]))]
[RequireComponent(typeof(AudioSource))]
public class EasyTalk : MonoBehaviour
{
    // Assets/Create EasyTalk Blendshape Map
    [Tooltip("Place the blendshape map file here. A blendshape map file can be initially generated by right-clicking on your model asset in your Project folder and selecting 'Create EasyTalk Blendshape Map'. Note that the resulting blendshape map file can/should be edited before being used here.")]
    public TextAsset BlendshapeMap;

    [HideInInspector]
    public class BlendshapeElement
    {
        public string MeshName;
        public int Index;
        public float Value;
    }

    [HideInInspector]
    /// <summary>
    /// Key: English, Viseme, Expression, French, Vulcan, etc
    ///      _
    ///      SIL, EH, ER, AA, etc
    /// </summary>    
    public Dictionary<string, List<BlendshapeElement>> BlendshapeDictionary = new Dictionary<string, List<BlendshapeElement>>();

    [System.Serializable]
    public class SequenceData : System.Object
    {
        public TextAsset SequenceFile;
        public AudioClip AudioClip;
        [HideInInspector]
        public List<TextAsset> ExpressionRecordings;
        [HideInInspector]
        public List<string> ExpressionRecordingTextAssetData;
        [HideInInspector]
        public string BasePath;
    }
    [Tooltip("Add any sequences you exported from the EasyTalk application to this section.")]
    public List<SequenceData> Sequences = new List<SequenceData>();

    [System.Serializable]
    public class BoneFix : System.Object
    {
        public Transform BoneTransform;
        public Vector3 DefaultRotation;
    }
    [Tooltip("Optional bone fixes: Add bones and their associated default rotations. Typically useful for lower jaw bones being stuck in an open position.")]
    public List<BoneFix> BoneFixes = new List<BoneFix>();

    //[Range(0, 1)]
    // Strengths are also set in the blendshape map files.
    private float _BlendshapeStrength = 1.0f;

    private AudioSource _AudioSource;

    private Dictionary<string, SkinnedMeshRenderer> _SkinnedMeshRenderers;

    // This will keep the Update() method from running before the Queues have been fully populated
    // which would obviously ruin the sequence playback.
    private bool _QueuesLocked = false;

    // Each sequence should be stored with a float (Timestamp) and a key name
    private class SpeechElement
    {
        public float Timestamp;
        public string KeyName;
    };
    // We store all sequences by sequence (file) name, then by layer name, then by list of elements in the 
    // layer. This may seem innefficient but is really only used for storing everything when
    // the game starts.
    //private Dictionary<string, Dictionary<string, List<VisemeElement>>> _SequenceFileNameThenLayerNameThenLayerSequenceElements = new Dictionary<string, Dictionary<string, List<VisemeElement>>>();
    private Dictionary<string, List<SpeechElement>> _SequenceSpeechElements = new Dictionary<string, List<SpeechElement>>();

    // This is a discrete element of our currently playing sequence
    private class SpeechQueueElement
    {
        public float StartTime;
        public float EndTime;
        public float PreCalculatedValue;
        public string StartKeyName;
        public string EndKeyName;
    }

    // There can only be one sequence playing for each layer, for a given sequence
    // at a time.
    //
    // The biggest performance penalty here is setting up the queue when you first
    // trigger a sequence. After that, you get just about the best performance 
    // in playback after that. We just pop informaton off of the queue handling
    // interpolation and paramater value lookups quickly. Don't sweat it too much.
    // .NET is pretty good at optimizing this stuff. If you are running a 486DX then
    // you might actually notice an issue.
    private Queue<SpeechQueueElement> _SequenceSpeechQueueElements = new Queue<SpeechQueueElement>();

    private float _PlayStartSequenceTime = 0.0f;

    private class ExpressionElement
    {
        public float Timestamp;
        public float Value;
    };
    private Dictionary<string, Dictionary<string, List<ExpressionElement>>> _SequenceParameterExpressionElements = new Dictionary<string, Dictionary<string, List<ExpressionElement>>>();
    private class ExpressionQueueElement
    {
        public string KeyName;
        public float StartTime;
        public float EndTime;
        public float StartValue;
        public float EndValue;
    }
    private Dictionary<string, Queue<ExpressionQueueElement>> _SequenceQueueExpressions = new Dictionary<string, Queue<ExpressionQueueElement>>();

    // Loop playback variables
    private bool _LoopPlayback = false;

    private string _LastPlaySequenceName = "";

    /// <summary>
    /// Script Initialization
    /// </summary>
    void Start()
    {
        // Get AudioSource
        _AudioSource = GetComponent<AudioSource>();

        // Get all of the SkinnedMeshRenderers attached to this GameObject
        Transform[] transforms = GetComponentsInChildren<Transform>();
        _SkinnedMeshRenderers = new Dictionary<string, SkinnedMeshRenderer>();
        foreach (Transform transform in transforms)
        {
            SkinnedMeshRenderer skinnedMeshRenderer = transform.GetComponent<SkinnedMeshRenderer>();
            if (skinnedMeshRenderer != null)
                _SkinnedMeshRenderers.Add(skinnedMeshRenderer.sharedMesh.name, skinnedMeshRenderer);
        }

        // Populate BlendshapeDictionary
        GetBlendshapeDictionary();

        if (Application.isEditor)
        {
            // We load the raw expression sequence data into some private variables because TextAsset's are read-only
            // which means we would have to reload the file, and do a refresh on the AssetDatabase within the 
            // editor script everytime we finish recording. This make for more code, more potential bugs, and a minor 
            // performance decrease.
            foreach (SequenceData sequence in Sequences)
            {
                sequence.ExpressionRecordingTextAssetData = new List<string>();
                foreach (TextAsset expressionRecordingTextAsset in sequence.ExpressionRecordings)
                {
                    try
                    {
                        sequence.ExpressionRecordingTextAssetData.Add(expressionRecordingTextAsset.text);
                    }
                    catch (UnityException ex)
                    {
                        Debug.LogException(ex);
                    }
                }
            }
        }

        LoadSequenceFiles();
    }

    private void LoadSequenceFiles()
    {
        _SequenceSpeechQueueElements = new Queue<SpeechQueueElement>();
        _SequenceSpeechElements = new Dictionary<string, List<SpeechElement>>();
        _SequenceParameterExpressionElements = new Dictionary<string, Dictionary<string, List<ExpressionElement>>>();
        _SequenceQueueExpressions = new Dictionary<string, Queue<ExpressionQueueElement>>();

        foreach (SequenceData sequence in Sequences)
        {
            // Load up expression data:
            Dictionary<string, List<ExpressionElement>> parameterExpressionElements = new Dictionary<string, List<ExpressionElement>>();
            _SequenceParameterExpressionElements.Add(sequence.SequenceFile.name, parameterExpressionElements);
            for (int i = 0; i < sequence.ExpressionRecordings.Count; i++)
            {
                string[] expressionElements;
                if (Application.isEditor)
                {
                    expressionElements = sequence.ExpressionRecordingTextAssetData[i].Split(new[] { ',' }, System.StringSplitOptions.RemoveEmptyEntries);
                }
                else
                {
                    expressionElements = sequence.ExpressionRecordings[i].text.Split(new[] { ',' }, System.StringSplitOptions.RemoveEmptyEntries);
                }
                if (expressionElements.Length % 2 != 0)
                {
                    throw new UnityException(string.Format("The expresions file TextAsset named, '{0}' does not contain a number of elements divisible by two.", sequence.ExpressionRecordings[i].name));
                }
                else
                {
                    List<ExpressionElement> expressionElementsList = new List<ExpressionElement>();
                    for (int j = 0; j < expressionElements.Length; j += 2)
                    {
                        ExpressionElement expressionElement = new ExpressionElement()
                        {
                            Timestamp = float.Parse(expressionElements[j]),
                            Value = float.Parse(expressionElements[j + 1]),
                        };
                        expressionElementsList.Add(expressionElement);
                    }
                    string[] elements = sequence.ExpressionRecordings[i].name.Split(new[] { '.' });
                    string name = elements[elements.Length - 1];
                    _SequenceParameterExpressionElements[sequence.SequenceFile.name].Add(name, expressionElementsList);
                }
            }

            // Load up Viseme data:
            string sequenceName = sequence.SequenceFile.name;
            // Initialize everything if it does not exist:
            if (_SequenceSpeechElements.ContainsKey(sequenceName) == false)
            {
                _SequenceSpeechElements.Add(sequenceName, new List<SpeechElement>());
            }
            // Parse the file
            string visemeSequenceText = GetVisemeSequenceText(sequence.SequenceFile.text);
            string[] visemeElements = visemeSequenceText.Split(new[] { ',' }, System.StringSplitOptions.RemoveEmptyEntries);
            if (visemeElements.Length % 2 != 0)
            {
                throw new UnityException(string.Format("The sequence file TextAsset named, '{0}' does not contain a number of elements divisible by two", sequenceName));
            }
            else
            {
                string[] nameElements = sequenceName.Split(new char[] { '_' });
                string keyPrefix = nameElements[nameElements.Length - 1];
                for (int i = 0; i < visemeElements.Length; i += 2)
                {
                    string parameterName = visemeElements[i + 1];
                    SpeechElement visemeElement = new SpeechElement()
                    {
                        Timestamp = float.Parse(visemeElements[i]),
                        KeyName = keyPrefix + "_" + parameterName
                    };
                    _SequenceSpeechElements[sequenceName].Add(visemeElement);
                }
            }
        }
    }

    /// <summary>
    /// Stops a currently playing squence.
    /// </summary>
    public void StopSequence()
    {
        _QueuesLocked = true;
        _AudioSource.Stop();
        // Clear Queues
        _SequenceSpeechQueueElements.Clear();
        _SequenceQueueExpressions.Clear();
        // Reset all of our blendshapes
        foreach (KeyValuePair<string, List<EasyTalk.BlendshapeElement>> kvp in BlendshapeDictionary)
        {
            BlendshapeDriver(kvp.Key, 0.0f);
        }
        _QueuesLocked = false;

        /* Uncomment for debugging:
        DebugDumpRecordedBlendshapeWeights();
        */
    }

    /// <summary>
    /// Plays a sequence.
    /// </summary>
    /// <param name="sequenceName">The sequence name.</param>    
    public void PlaySequence(string sequenceName)
    {
        PlaySequence(sequenceName, false);
    }

    /// <summary>
    /// Plays a sequence with optional looping. Works well for idle sequences.
    /// </summary>
    /// <param name="sequenceName">The sequence name.</param>
    /// <param name="loop">true to loop the sequence playback, else false</param>
    public void PlaySequence(string sequenceName, bool loop)
    {
        _LoopPlayback = loop;

        if (_SequenceSpeechElements.ContainsKey(sequenceName) == false)
        {
            Debug.Log(string.Format("Error: The call to PlaySequence('{0}') failed because there is no sequence named, '{0}' for this instance of the '{1}' object in your scene.", sequenceName, this.gameObject.name));
            Debug.LogError(string.Format("Error: The call to PlaySequence('{0}') failed because there is no '{0}' sequence defined for this instance of the '{1}' object in your scene.", sequenceName, this.gameObject.name));
            return;
        }
        _QueuesLocked = true;
        // Select audio clip:
        foreach (SequenceData sequence in Sequences)
        {
            if (sequence.SequenceFile.name == sequenceName)
            {
                _AudioSource.clip = sequence.AudioClip;
            }
        }
        _PlayStartSequenceTime = Time.fixedTime;
        // As soon as you set playSequenceTime, you need to start playing audio to keep things in sync.
        // The playback of the sequence will be synced this way and will play correctly no matter
        // how long setup takes in this method. This is the desired result. If the sequence is really long,
        // it might be best to have some silent audio data for X number of seconds at the beginning of the
        // audio clip.
        _AudioSource.Play();
        _SequenceSpeechQueueElements = new Queue<SpeechQueueElement>();

        // Save the currently playing sequence name.
        _LastPlaySequenceName = sequenceName;

        _SequenceSpeechQueueElements.Clear();
        List<SpeechElement> speechElement = _SequenceSpeechElements[sequenceName];
        //int sequenceQueueLayerIndex = _SequenceQueueVisemes.Count - 1;
        for (int i = 0; i < speechElement.Count - 1; i++)
        {
            SpeechElement firstSequenceElement = speechElement[i];
            SpeechElement lastSequenceElement = speechElement[i + 1];
            _SequenceSpeechQueueElements.Enqueue(new SpeechQueueElement()
            {
                StartTime = _PlayStartSequenceTime + firstSequenceElement.Timestamp,
                EndTime = _PlayStartSequenceTime + lastSequenceElement.Timestamp,
                PreCalculatedValue = _BlendshapeStrength / ((_PlayStartSequenceTime + lastSequenceElement.Timestamp) - (_PlayStartSequenceTime + firstSequenceElement.Timestamp)),
                StartKeyName = firstSequenceElement.KeyName,
                EndKeyName = lastSequenceElement.KeyName
            });
        }

        _SequenceQueueExpressions = new Dictionary<string, Queue<ExpressionQueueElement>>();
        _SequenceQueueExpressions.Clear();

        foreach (KeyValuePair<string, List<ExpressionElement>> parameter in _SequenceParameterExpressionElements[sequenceName])
        {
            string parameterName = parameter.Key;
            List<ExpressionElement> sequence = parameter.Value;
            _SequenceQueueExpressions.Add(parameterName, new Queue<ExpressionQueueElement>());
            //int sequenceQueueLayerIndex = _SequenceQueueExpressions.Count - 1;
            for (int i = 0; i < sequence.Count - 1; i++)
            {
                ExpressionElement firstSequenceElement = sequence[i];
                ExpressionElement lastSequenceElement = sequence[i + 1];
                _SequenceQueueExpressions[parameterName].Enqueue(new ExpressionQueueElement()
                {
                    KeyName = parameterName,
                    StartTime = _PlayStartSequenceTime + firstSequenceElement.Timestamp,
                    EndTime = _PlayStartSequenceTime + lastSequenceElement.Timestamp,
                    StartValue = firstSequenceElement.Value,
                    EndValue = lastSequenceElement.Value
                });
            }
        }

        _QueuesLocked = false;
    }

    /// <summary>
    /// Determines if a sequence is currently playing.
    /// </summary>
    /// <returns>true if a sequence is currently playing, otherwise false</returns>
    public bool IsSequencePlaying()
    {
        // If visemes elements remain to be played, sequence is still playing
        if (_SequenceSpeechQueueElements.Count > 0)
            return true;

        if (string.IsNullOrEmpty(_LastPlaySequenceName) == false)
        {
            // If expression elements remain to be played, sequence is still playing
            foreach (KeyValuePair<string, List<ExpressionElement>> layer in _SequenceParameterExpressionElements[_LastPlaySequenceName])
            {
                string layerName = layer.Key;
                if (_SequenceQueueExpressions[layerName].Count > 0)
                    return true;
            }
        }
        return false;
    }

    private float LinearInterpolation(float x1, float y1, float x2, float y2, float x)
    {
        return y1 + (((x - x1) * (y2 - y1)) / (x2 - x1));
    }

    /* Uncomment for debugging:
    private List<string> DebugRecordedBlendshapeWeights = new List<string>();
    private void DebugRecordBlendshapeWeights()
    {
        float currentTime = Time.fixedTime;

        Transform[] transforms = GetComponentsInChildren<Transform>();
        foreach (Transform transform in transforms)
        {
            SkinnedMeshRenderer skinnedMeshRenderer = transform.GetComponent<SkinnedMeshRenderer>();
            if (skinnedMeshRenderer != null)
            {
                for (int i=0; i<skinnedMeshRenderer.sharedMesh.blendShapeCount; i++)
                {
                    float value = skinnedMeshRenderer.GetBlendShapeWeight(i);
                    if (value !=0)
                    {
                        DebugRecordedBlendshapeWeights.Add(string.Format("{0} : {1}[(index={2}){3}]={4}", currentTime, skinnedMeshRenderer.sharedMesh, i, skinnedMeshRenderer.sharedMesh.GetBlendShapeName(i), value));
                    }
                }                
            }
        }
    }
    private void DebugDumpRecordedBlendshapeWeights()
    {
        StringBuilder sb = new StringBuilder();
        foreach (string line in DebugRecordedBlendshapeWeights)
        {
            sb.AppendLine(line);
        }
        File.WriteAllText("dump.txt", sb.ToString());
    }
    */

    void LateUpdate()
    {
        /* Uncomment for debugging:
        DebugRecordBlendshapeWeights();
        */

        // Adjust bones in LateUpdate typically useful for lower jaw bone stuck open issues.
        foreach (BoneFix boneFix in BoneFixes)
        {
            boneFix.BoneTransform.localEulerAngles = boneFix.DefaultRotation;
        }

        // To correctly keep the queue.Dequeue() in sync with our animation / blendshape driver calls below,
        // we get the current time in a variable.
        //
        float currentTime = Time.fixedTime;

        if (_QueuesLocked == false)
        {
            if (_LoopPlayback && IsSequencePlaying() == false)
            {
                // Replay the last successfully played sequence
                PlaySequence(_LastPlaySequenceName, _LoopPlayback);
                return;
            }

            // Cycle through speech "layer" first
            if (_SequenceSpeechQueueElements.Count > 0)
            {
                Queue<SpeechQueueElement> queue = _SequenceSpeechQueueElements;
                if (queue.Count > 0)
                {
                    SpeechQueueElement queueElement;
                    while (true)
                    {
                        queueElement = queue.Peek();
                        if (currentTime > queueElement.EndTime)
                        {
                            BlendshapeDriver(queueElement.StartKeyName, 0.0f);
                            queue.Dequeue();
                            if (queue.Count == 0)
                            {
                                break;
                            }
                            queueElement = queue.Peek();
                        }
                        else
                        {
                            break;
                        }
                    }
                    if (queue.Count > 0)
                    {
                        //float endParameterValue = LinearInterpolation(queueElement.StartTime, 0.0f, queueElement.EndTime, MaxStrength, currentTime);
                        // Downside of PreCalculatedValue is that we can't dynamically adjust strength
                        float endParameterValue = (((currentTime - queueElement.StartTime) * (queueElement.PreCalculatedValue)));

                        float startParameterValue = _BlendshapeStrength - endParameterValue;
                        //Debug.Log("----------------------------------- FRAME ---------------------------------------");
                        BlendshapeDriver(queueElement.StartKeyName, startParameterValue);
                        BlendshapeDriver(queueElement.EndKeyName, endParameterValue);
                    }
                }
            }

            foreach (KeyValuePair<string, Queue<ExpressionQueueElement>> queue in _SequenceQueueExpressions)
            {
                if (queue.Value.Count > 0)
                {
                    ExpressionQueueElement queueElement;
                    while (true)
                    {
                        queueElement = queue.Value.Peek();
                        if (currentTime > queueElement.EndTime)
                        {
                            queue.Value.Dequeue();
                            if (queue.Value.Count == 0)
                            {
                                break;
                            }
                            queueElement = queue.Value.Peek();
                        }
                        else
                        {
                            break;
                        }
                    }
                    if (queue.Value.Count > 0)
                    {
                        float parameterValue = LinearInterpolation(queueElement.StartTime, queueElement.StartValue, queueElement.EndTime, queueElement.EndValue, currentTime);
                        BlendshapeDriver(queueElement.KeyName, parameterValue * _BlendshapeStrength);
                    }
                }
            }
        }

        #region UNITY EDITOR CODE
        // Quick check to see if we are running in the editor to enable recording.
        // This ensures we are not wasting resources in an actual build where only
        // sequence playback is required.
#if UNITY_EDITOR
        if (Application.isEditor)
        {
            EditorRecorder(currentTime);
        }
#endif
        #endregion
    }

    private void BlendshapeDriver(string keyname, float value)
    {
        /* Uncomment for debugging:
        if (value>1)
        {
            Debug.Log("BlendshapeDriver ERROR: value>1 ... value="+ value);
            //value = 1;
        }
        */
        foreach (KeyValuePair<string, List<BlendshapeElement>> kvp in BlendshapeDictionary)
        {
            if (keyname == kvp.Key)
            {
                foreach (BlendshapeElement blendshapeElement in kvp.Value)
                {
                    if (_SkinnedMeshRenderers.ContainsKey(blendshapeElement.MeshName))
                    {
                        _SkinnedMeshRenderers[blendshapeElement.MeshName].SetBlendShapeWeight(blendshapeElement.Index, (value * blendshapeElement.Value));
                        /* Uncomment for debugging:
                        // Debug.Log(Time.fixedTime + " : " + blendshapeElement.MeshName + " -> " + keyname + " -> " + value * blendshapeElement.Value);
                        if (keyname=="English_AA" || keyname == "English_R")
                        {
                            Debug.Log(Time.fixedTime + " : " + blendshapeElement.MeshName + " -> " + keyname + " -> " + value * blendshapeElement.Value);
                        }
                        */
                    }
                }
            }
        }
    }

    [System.Serializable]
    public class EasyTalkElement
    {
        public string EncryptedElement;
    }

    [System.Serializable]
    public class EasyTalkFile
    {
        public EasyTalkElement[] EasyTalkElements;
    }

    private string GetVisemeSequenceText(string text)
    {
        try
        {
            EasyTalkFile easyTalkFile = JsonUtility.FromJson<EasyTalkFile>(text);

            StringBuilder sb = new StringBuilder();
            using (var rsa = new RSACryptoServiceProvider(1024))
            {
                // WARNING: Sharing this decryption key publicly or with anyone other than the license holder
                //          is a voilation of the license agreement provided to you by Realtime VR, LLC.
                rsa.FromXmlString("<RSAKeyValue><Modulus>u09tFZvmokQZQCgBatIy4HW+IYGOOJS70juBzP69rDS+aZN+KA0rpYr5CM9BPVXYteK5Hn0FlBdZFnkfD02c57fpO/T0tLoQbXgdNCa0O/EZG98EoocGHHbSLnJBaO4Y1bi2yIt2aGjGV2dXnhWDYjrR9x5fJkzzudVZTfKLQ1E=</Modulus><Exponent>AQAB</Exponent><P>6WEYJSm56UewmXnBaAw6acsrgu9BVQEyuzbR1O/WWfEkmEJpfXUdUXjJq8YiOvxTj4ZCde7DwaMdb77ofih+Pw==</P><Q>zXc1U/EIKCJb81d27NvMszph1yVnw1w9wz92qbL3e9MuI+JdmXlaqaUetalV65hKdGBlcDDfmhiBjrSdFY36bw==</Q><DP>ovakyJaJdkcUHydxETmwtF0lpglxomzywt31ye4rzKRhfFyrkuprrY9dq6/wCSZXJxqGYBl44kcHcBdr+2RFOw==</DP><DQ>B9dFxLdNDWMKSUYMNsvIiwpuU2yNAiqR/NJ+L8mxohsUBrCLy+CSsiin/FzC96OvK7PGCzsCPXoz74M6/2iUpw==</DQ><InverseQ>R3iXXUGpcPYfq8s1Q3d+w9SoREiRQxXnKGLO7XKPFD/oTzFLxsQ55ROXQSJAklBfnnezqGb95RXhJo0cOcQfMQ==</InverseQ><D>FFBXWL4ZI6T2BhawnKiiOuSaE6EszucWfYTVnWlNIbVwpxuHVYmkH6Z0PqfXf/Lk90jY4b0WU0q67yyAmVTF/M3Fy89jwiTXMnCiQ3OrzVjorA6vxeHh6hCbytMCcviPBculfAHq0kDaQPwngqGohGAeYe+MN8O4XXTL49ChDD8=</D></RSAKeyValue>");
                foreach (EasyTalkElement easyTalkElement in easyTalkFile.EasyTalkElements)
                {
                    sb.Append(Encoding.Unicode.GetString(rsa.Decrypt(System.Convert.FromBase64String(easyTalkElement.EncryptedElement), false)));
                }
            }
            return sb.ToString();
        }
        catch (System.Exception ex)
        {
            return text;
        }
    }

    #region UNITY EDITOR CODE
#if UNITY_EDITOR


    /* ***************************************************************************************************************************************************************************************************
     * ***************************************************************************************************************************************************************************************************
     * ***************************************************************************************************************************************************************************************************
     * Code and variables for editor use are below. These are present but are not used in your build.
     * ***************************************************************************************************************************************************************************************************
     * ***************************************************************************************************************************************************************************************************
     * ***************************************************************************************************************************************************************************************************
     */

    Vector3 mousePos = new Vector3();

    [HideInInspector]
    public int SelectedSequenceIndex = 0;

    [System.Serializable]
    public class ExpressionController : System.Object
    {
        public string KeyName;
        public bool Record;
        public List<string> RecordingElements;
        public float LastRecordingTimeStamp;
        public string SelectedInputControllerName;
        public int SelectedInputControllerIndex;
        public float CurrentInputControllerValue = 0.0f;
    }
    [HideInInspector]
    public List<ExpressionController> ExpressionControllerList = new List<ExpressionController>();

    public enum ButtonNames
    {
        None = KeyCode.None,
        Space = KeyCode.Space,
        JoystickButton0 = KeyCode.JoystickButton0,
        JoystickButton1 = KeyCode.JoystickButton1,
        JoystickButton2 = KeyCode.JoystickButton2,
        JoystickButton3 = KeyCode.JoystickButton3,
        JoystickButton4 = KeyCode.JoystickButton4,
        JoystickButton5 = KeyCode.JoystickButton5,
        JoystickButton6 = KeyCode.JoystickButton6,
        JoystickButton7 = KeyCode.JoystickButton7,
        JoystickButton8 = KeyCode.JoystickButton8,
        JoystickButton9 = KeyCode.JoystickButton9,
        Return = KeyCode.Return,
        LeftShift = KeyCode.LeftShift,
        RightShift = KeyCode.RightShift,
        Mouse0 = KeyCode.Mouse0,
        Mouse1 = KeyCode.Mouse1,
        Mouse2 = KeyCode.Mouse2
    };

    [HideInInspector]
    public ButtonNames RecordButton = ButtonNames.None;

    [HideInInspector]
    public ButtonNames PlayButton = ButtonNames.None;

    public enum State
    {
        Standby,
        Recording,
        Playing
    }

    [HideInInspector]
    public State _State;

    /// <summary>
    /// _Active indicates that recording will be activated for the associated game object.
    /// </summary>
    [HideInInspector]
    public bool _Active = false;

    [HideInInspector]
    public bool _DisplayAllRecordedExpressionsOnPlayback = true;

    [HideInInspector]
    public bool _GameWindowHasFocus = false;

    public enum NextOperation
    {
        None,
        StartRecording,
        StopRecording,
        StartPlaying,
        StopPlaying
    }

    private static string _StandbyText = "<size=20><color=yellow><b><i>STANDBY / READY</i></b></color></size>";
    private static string _RecordingText = "<size=20><color=yellow><b><i>RECORDING</i></b></color></size>";
    private static string _PlayingText = "<size=20><color=yellow><b><i>PLAYING</i></b></color></size>";
    private string _StatusText = _StandbyText;

    void OnGUI()
    {
        GUIStyle style = new GUIStyle();
        style.richText = true;
        GUILayout.Label(_StatusText, style);
    }

    private void OnApplicationFocus(bool focusStatus)
    {
        // Quick check to see if we are running in the editor.
        // This ensures we are not wasting resources in an actual build.  
        if (Application.isEditor)
        {
            _GameWindowHasFocus = focusStatus;
        }
    }

    private void EditorRecorder(float currentTime)
    {
        // Quick check to see if we are running in the editor to enable recording.
        // This ensures we are not wasting resources in an actual build.  
        if (Application.isEditor)
        {
            // Prevent anything from happening if the correct object is not selected in the hierarchy. 
            // This helps avoid confusion to the end-user because we won't be able to record.
            // Playback would work while recording would not if a game object with the LipSyncExpression.cs 
            // script attached is not selected.
            // Better to force user to select a game object with the LipSyncExpression.cs script attached.
            //
            // Also note that user can have more than one object selected. We want to ensure that only
            // ONE object is selected and that that object contains the LipSyncExpression.cs script component.
            _StatusText = "";
            GameObject[] selectedGameObjects = UnityEditor.Selection.gameObjects;
            if (selectedGameObjects.Length != 1)
                return;
            string selectedGameObjectName = selectedGameObjects[0].name;
            if (!_Active)
                return;
            if (selectedGameObjectName != gameObject.name)
                return;
            _StatusText = "<size=14><color=yellow><b>" + "EasyTalk (" + gameObject.name + "):\n" + "</b></color></size>";
            if (_GameWindowHasFocus == false)
            {
                _StatusText += "<size=16><color=yellow><i>\n(You need to click in this Game window to enable device input...)</i></color></size>";
                return;
            }

            // If recording, record button stops recording
            // If recording, play button stops recording
            // If playing, record button stops playing
            // If playing, play button stops playing
            // If standby, record button starts recording
            // If standby, play button starts play
            NextOperation nextOperation = NextOperation.None;
            if (_State == State.Recording)
            {
                if (Input.GetKeyDown((KeyCode)RecordButton))
                {
                    nextOperation = NextOperation.StopRecording;
                }
                if (Input.GetKeyDown((KeyCode)PlayButton))
                {
                    nextOperation = NextOperation.StopRecording;
                }
            }
            else if (_State == State.Playing)
            {
                // Determine if the viseme or expression queues still have data.
                // This will determine whether a sequence is still playing.
                if (IsSequencePlaying() == false)
                {
                    nextOperation = NextOperation.StopPlaying;
                }
                else
                {
                    if (Input.GetKeyDown((KeyCode)RecordButton))
                    {
                        nextOperation = NextOperation.StopPlaying;
                    }
                    if (Input.GetKeyDown((KeyCode)PlayButton))
                    {
                        nextOperation = NextOperation.StopPlaying;
                    }
                }
            }
            else if (_State == State.Standby)
            {
                if (Input.GetKeyDown((KeyCode)RecordButton))
                {
                    nextOperation = NextOperation.StartRecording;
                }
                if (Input.GetKeyDown((KeyCode)PlayButton))
                {
                    nextOperation = NextOperation.StartPlaying;
                }
            }
            switch (nextOperation)
            {
                case NextOperation.StartPlaying:
                    PlaySequence(Sequences[SelectedSequenceIndex].SequenceFile.name);
                    _State = State.Playing;
                    break;
                case NextOperation.StartRecording:
                    foreach (ExpressionController parameterController in ExpressionControllerList)
                    {
                        parameterController.RecordingElements = new List<string>();
                        parameterController.LastRecordingTimeStamp = 0;
                    }
                    PlaySequence(Sequences[SelectedSequenceIndex].SequenceFile.name);
                    _State = State.Recording;
                    break;
                case NextOperation.StopPlaying:
                    StopSequence();
                    _State = State.Standby;
                    break;
                case NextOperation.StopRecording:
                    _AudioSource.Stop();
                    // Clear Queues
                    _SequenceSpeechQueueElements.Clear();
                    _SequenceQueueExpressions.Clear();
                    // Save data to file and temporary memory
                    foreach (ExpressionController expressionController in ExpressionControllerList)
                    {
                        if (expressionController.Record == true)
                        {
                            StringBuilder sb = new StringBuilder();
                            for (int i = 1; i < expressionController.RecordingElements.Count - 1; i += 2)
                            {
                                sb.Append(expressionController.RecordingElements[i - 1]);
                                sb.Append(",");
                                sb.Append(expressionController.RecordingElements[i]);
                                sb.Append(",");
                            }
                            if (sb.Length >= 2)
                            {
                                sb.Remove(sb.Length - 1, 1);
                                string fileText = sb.ToString();
                                File.WriteAllText(Sequences[SelectedSequenceIndex].BasePath + "." + expressionController.KeyName + ".txt", fileText);
                                for (int i = 0; i < Sequences[SelectedSequenceIndex].ExpressionRecordings.Count; i++)
                                {
                                    if (Sequences[SelectedSequenceIndex].ExpressionRecordings[i].name.EndsWith(expressionController.KeyName))
                                    {
                                        Sequences[SelectedSequenceIndex].ExpressionRecordingTextAssetData[i] = fileText;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    LoadSequenceFiles();
                    // Reset all of our blendshapes
                    foreach (KeyValuePair<string, List<EasyTalk.BlendshapeElement>> kvp in BlendshapeDictionary)
                    {
                        BlendshapeDriver(kvp.Key, 0.0f);
                    }
                    _State = State.Standby;
                    break;
            }
            // Display current state on GUI
            switch (_State)
            {
                case State.Playing:
                    _StatusText += _PlayingText + (_DisplayAllRecordedExpressionsOnPlayback ? "<size=14><color=yellow><b> (Input preview disabled. Playing final recording.)</b></color></size>" : "<size=14><color=yellow><b> (Input preview enabled. Record preview mode.)</b></color></size>");
                    break;
                case State.Recording:
                    _StatusText += _RecordingText;
                    break;
                case State.Standby:
                    _StatusText += _StandbyText;
                    break;
            }

            // This try/catch block just supresses some initial, insignificant errors in the Unity 
            // editor console window. 
            try
            {
                // Get the input values
                foreach (KeyValuePair<string, List<EasyTalk.BlendshapeElement>> kvp in BlendshapeDictionary)
                {
                    for (int i = 0; i < ExpressionControllerList.Count; i++)
                    {
                        if (ExpressionControllerList[i].KeyName == kvp.Key)
                        {
                            ExpressionControllerList[i].CurrentInputControllerValue = 0.0f;
                            if (ExpressionControllerList[i].SelectedInputControllerName.StartsWith("LSE-Mouse"))
                            {
                                mousePos = mousePos + new Vector3(Input.mousePosition.x, Input.mousePosition.y, 125);
                                if (ExpressionControllerList[i].SelectedInputControllerName.StartsWith("LSE-MouseX"))
                                {
                                    ExpressionControllerList[i].CurrentInputControllerValue = (Input.mousePosition.x / Screen.width) - 0.5f;
                                }
                                else
                                {
                                    ExpressionControllerList[i].CurrentInputControllerValue = (Input.mousePosition.y / Screen.height) - 0.5f;
                                }
                                if (ExpressionControllerList[i].CurrentInputControllerValue > 1.0f)
                                    ExpressionControllerList[i].CurrentInputControllerValue = 1.0f;
                                if (ExpressionControllerList[i].CurrentInputControllerValue < -1.0f)
                                    ExpressionControllerList[i].CurrentInputControllerValue = -1.0f;
                            }
                            else
                            {
                                try
                                {
                                    ExpressionControllerList[i].CurrentInputControllerValue = Input.GetAxis(ExpressionControllerList[i].SelectedInputControllerName);
                                }
                                catch (System.ArgumentException argEx)
                                {
                                    // This error occurs if the input device is not supported. Ex: Input.GetAxis("None") is one we are using.
                                    // For best debugging, enable following line:                                
                                    //
                                    //
                                    //   Debug.Log("Error: You may need to select the character in the Hierarchy... Message is as follows: " + argEx);
                                    System.ArgumentException argExCopy = argEx;
                                }
                                catch (UnityException ex)
                                {
                                    throw ex;
                                }
                            }

                            if (ExpressionControllerList[i].SelectedInputControllerName.EndsWith("-"))
                            {
                                ExpressionControllerList[i].CurrentInputControllerValue = -1.0f * ExpressionControllerList[i].CurrentInputControllerValue;
                            }
                            break;
                        }
                    }
                }
            }
            catch (UnityException ex)
            {
                Debug.Log("Error: You may need to select the character in the Hierarchy... Message is as follows: " + ex);
            }

            // Display expression feedback from input device controls:
            foreach (ExpressionController expressionController in ExpressionControllerList)
            {
                if (_State == State.Recording)
                {
                    if (expressionController.Record)
                    {
                        BlendshapeDriver(expressionController.KeyName, expressionController.CurrentInputControllerValue * _BlendshapeStrength);
                    }
                }
                else if (_State == State.Playing)
                {
                    if (!_DisplayAllRecordedExpressionsOnPlayback)
                    {
                        if (expressionController.Record)
                        {
                            BlendshapeDriver(expressionController.KeyName, expressionController.CurrentInputControllerValue * _BlendshapeStrength);
                        }
                    }
                }
                else if (_State == State.Standby)
                {
                    if (expressionController.Record)
                    {
                        foreach (KeyValuePair<string, List<EasyTalk.BlendshapeElement>> kvp in BlendshapeDictionary)
                        {
                            if (kvp.Key == expressionController.KeyName)
                            {
                                BlendshapeDriver(expressionController.KeyName, expressionController.CurrentInputControllerValue * _BlendshapeStrength);
                                break;
                            }
                        }
                    }
                }
            }

            if (_State == State.Recording)
            {
                // This try/catch block just supresses some initial errors in the Unity 
                // editor console window.
                try
                {
                    // Record:
                    foreach (KeyValuePair<string, List<EasyTalk.BlendshapeElement>> kvp in BlendshapeDictionary)
                    {
                        foreach (ExpressionController parameterController in ExpressionControllerList)
                        {
                            if (parameterController.KeyName == kvp.Key)
                            {
                                if (parameterController.Record == true)
                                {
                                    float recordingTimeStamp = currentTime - _PlayStartSequenceTime;
                                    // Our record rate is limited to 0.05
                                    if (recordingTimeStamp - parameterController.LastRecordingTimeStamp > 0.05f)
                                    {
                                        parameterController.LastRecordingTimeStamp = recordingTimeStamp;

                                        parameterController.RecordingElements.Add(recordingTimeStamp.ToString());
                                        parameterController.RecordingElements.Add(parameterController.CurrentInputControllerValue.ToString());
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
                catch (System.Exception ex)
                {
                    Debug.Log(ex.Message);
                }
            }
        }
    }
#endif
    #endregion

    public void GetBlendshapeDictionary()
    {
        BlendshapeDictionary = new Dictionary<string, List<BlendshapeElement>>();
        if (BlendshapeMap != null)
        {
            List<List<string>> csvContents = CsvFileParser(BlendshapeMap.text);
            foreach (List<string> row in csvContents)
            {
                if (row.Count != 6)
                {
                    BlendshapeDictionary = new Dictionary<string, List<BlendshapeElement>>();
                    break;
                }
                // Key might be something like, "English_SH"
                if (row[0].Length > 0 && row[1].Length > 0 && row[2].Length > 0 && row[3].Length > 0 && row[4].Length > 0 && row[5].Length > 0)
                {
                    string key = string.Format("{0}_{1}", row[0], row[1]);

                    // TODO: int.Parse = BAD. This can be more robust.
                    BlendshapeElement blendshapeElement = new BlendshapeElement()
                    {
                        Index = int.Parse(row[3]),
                        MeshName = row[2],
                        Value = float.Parse(row[5])
                    };

                    if (BlendshapeDictionary.ContainsKey(key))
                    {
                        // Add to it
                        BlendshapeDictionary[key].Add(blendshapeElement);
                    }
                    else
                    {
                        BlendshapeDictionary.Add(key, new List<BlendshapeElement>() { blendshapeElement });
                    }
                }
            }
        }
    }

    private List<List<string>> CsvFileParser(string text)
    {
        List<List<string>> result = new List<List<string>>();

        int numColumns = -1;
        bool addOneToColumnCount = false;
        string[] lines = text.Split(new char[] { '\n' });
        foreach (string line in lines)
        {
            if (line.EndsWith(",\r"))
                addOneToColumnCount = true;

            string row = line.Replace("\r", "");

            List<string> cells = new List<string>();

            int last = -1;
            int current = 0;
            bool inText = false;

            while (current < row.Length)
            {
                switch (row[current])
                {
                    case '"':
                        inText = !inText;
                        break;
                    case ',':
                        if (!inText)
                        {
                            string cellData = row.Substring(last + 1, (current - last)).Trim(' ', ',');
                            if (cellData.StartsWith("\"") && cellData.EndsWith("\""))
                                cellData = cellData.Substring(1, cellData.Length - 2);
                            cellData = cellData.Replace("\"\"", "\"");
                            cells.Add(cellData);
                            last = current;
                        }
                        break;
                    default:
                        break;
                }
                current++;
            }

            if (last != row.Length - 1)
            {
                string cellData = row.Substring(last + 1).Trim();
                if (cellData.StartsWith("\"") && cellData.EndsWith("\""))
                    cellData = cellData.Substring(1, cellData.Length - 2);
                cellData = cellData.Replace("\"\"", "\"");
                cells.Add(cellData);
            }

            if (numColumns == -1)
            {
                numColumns = cells.Count;
                if (addOneToColumnCount)
                    numColumns += 1;
            }

            // This can happen if the last column is empty
            if (cells.Count == numColumns - 1)
            {
                cells.Add("");
            }

            if (numColumns != cells.Count)
            {
                // Num cell columns not equal to inital number. 
                // Could be a bad CSV file or there is an extra line 
                // in the file at end... We're done!
                break;
            }
            else
            {
                result.Add(cells);
            }
        }
        return result;
    }

}
